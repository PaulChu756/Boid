<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Boid by PaulChu756</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Boid</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/PaulChu756/Boid" class="btn">View on GitHub</a>
      <a href="https://github.com/PaulChu756/Boid/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/PaulChu756/Boid/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>Paul Chu
AIE Year 2 Programming</p>

<p>I.0: Requirements Documentation
I.1: Description of the Problem
Name: Boids 
Problem Statement: Boids is an Artificial intelligence behavior for flocking/herding behavior. 
Problem Specification:  These behaviors show similar behavior in flocks of birds or herds of cows/zebras. This simulation has three main behaviors that show to replicate life like forms. </p>

<p>I.2: Input Information
Name: Boids
Description: Input of cohesion, separation, and alignment sliders.
Type: Unity/Visual Studio
Range of Acceptable Values: Values were determined by the math. I multiply it with a small number with all the rules, so the program doesnâ€™t freak/glitch out. </p>

<p>I.3: Output Information
The program will output a flocking/herding behavior similar to birds or herds of cows.</p>

<p>I.4: User Interface Information
A GUI will display for user after they input information. After, the user can increase/decrease values on via sliders displayed.</p>

<p>II.0: Design Documentation
II.1: System Architecture Description
The program is split into two different scripts for organization. The main script in this project is BoidController.cs, this is the main part of the project, it handles all the rules of this project.</p>

<p>II.2: Information about the functions
File: BoidController.cs</p>

<p>Class:SpawnBoidControllerner
Data Members: MonoBehaviour</p>

<p>Name: boids
Description: A list of GameObject</p>

<p>Name: cohesionslider
Description: A slider</p>

<p>Name: separtionslider
Description: A slider</p>

<p>Name: alignmentslider
Description: A slider</p>

<p>Name: Target
Description: A Gameobject</p>

<p>Name: target
Description: A Toggle</p>

<p>Name: boid
Description: A public Gameobject</p>

<p>Name: Xmin, Ymin, Zmin, Xmax, Ymax, Zmax 
Description: Public integer that all equal zero. </p>

<p>Name: v1, v2, v3, v4, center, pv
Description: v1 to v1 are all velocities, center is the center velocity, pv is the perceived velocity.</p>

<p>Function: Start
Description: Spawns all the boids as the user begins the program.</p>

<p>Function: Update
Description: Applies all the rules to each boid each frame, and checks if the escape key is pressed to exit out the program.</p>

<p>Function: l_Vel
Parameters: GameObject lv
Description: This is the Limited Velocity, if the boid passes this limit, it will change the velocity so the boids do not break the program.</p>

<p>Function: Bounding Box
Parameters: Gameobject boid
Description: Creates a bounding box for the boids, it will push them back if they hit the bounding area.</p>

<p>Function: Distance
Parameters: Vector3 pos and pos2
Description: Distance formula between two boids</p>

<p>Function: rule1
Parameters: Gameobject Cohesion
Description: Finds the center of mass between all boids that are nearby, and the boids will fly closely to the center of mass.</p>

<p>Function: rule2
Parameters: Gameobject Separation
Description: Sets a distance away from each boid using distance formula</p>

<p>Function: rule3
Parameters: Gameobject Alignment
Description: Boids will fly in the same general direction of each other, instead of flying as individuals.
File: Boid.cs
Class: Boid
Data Members: MonoBehaviour</p>

<p>Name: Vel
Description: Vector3 for velocity</p>

<p>Function: Mag
Parameters: Vector3 pos1
Description: Getting the magnitude by from position and direction / vector3</p>

<p>Function: Update
Description: Gets all the boid gameobjects to face correctly right, and checks if the escape key is pressed to exit program.</p>

<p>III.0: Implementation Documentation
III.1 Program Code</p>

<h1>
<a id="file-boidcontrollercs" class="anchor" href="#file-boidcontrollercs" aria-hidden="true"><span class="octicon octicon-link"></span></a>File: BoidController.cs</h1>

<p>using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;</p>

<p>public class BoidController : MonoBehaviour
{
    public List boids = new List();
    public Slider cohesionslider;
    public Slider separtionslider;
    public Slider alignmentslider;
    public GameObject Target;
    public Toggle target;
    public GameObject boid;
    public float cFac, sFac, aFac, vLim;
    public int Xmin = 0, Ymin = 0, Zmin = 0, Xmax = 0, Ymax = 0, Zmax = 0; // Draws Box</p>

<pre><code>Vector3 v1;
Vector3 v2;
Vector3 v3;
Vector3 v4;
Vector3 center;
Vector3 pv;

/// &lt;summary&gt;
/// create the list of boids in random positions
/// &lt;/summary&gt;
[ContextMenu("populate")] // Matthew's code
void Populate()
{
    GameObject bird;
    for (int i = 0; i &lt; 25; i++) // Control how many number of boids on Screen
    {
        bird = Instantiate(boid) as GameObject;
        float rX = Random.Range(0, 20);
        float rY = Random.Range(0, 20);
        float rZ = Random.Range(0, 20);
        bird.transform.position = new Vector3(rX, rY, rZ);
        boids.Add(bird);
    }
}

[ContextMenu("Unpopulate")] // Matthew's code
void UnPopulate()
{
    foreach(GameObject go in boids)
    {
        DestroyImmediate(go);
    }
    boids.Clear();
}

void Start()
{
       GameObject bird;
       for (int i = 0; i &lt; 25; i++) // Control how many number of boids on Screen
       {
           bird = Instantiate(boid) as GameObject;
           float rX = Random.Range(0, 20);
           float rY = Random.Range(0, 20);
           float rZ = Random.Range(0, 20);
           bird.transform.position = new Vector3(rX, rY, rZ);
           boids.Add(bird);
       }
}

void Update()
{
    foreach (GameObject boid in boids)
    {
        v1 = rule1(boid) * cohesionslider.value * cFac; // Cohesion
        v2 = rule2(boid) * separtionslider.value * sFac;
        v3 = rule3(boid) * alignmentslider.value * aFac;
        v4 = boundingBox(boid);
        boid.GetComponent&lt;Boid&gt;().Vel = boid.GetComponent&lt;Boid&gt;().Vel + v1 + v2 + v3 + v4; // Vel + all rules
        l_Vel(boid);
        boid.transform.position = boid.transform.position + boid.GetComponent&lt;Boid&gt;().Vel; // Adding the pos + Vel
    }
    if (Input.GetKey("escape"))
    {
        Application.Quit();
    }
}

void l_Vel(GameObject lv) // Velocity Limit
{
    Vector3 velocity = lv.GetComponent&lt;Boid&gt;().Vel;
    if (velocity.magnitude &gt; vLim)
    {
        velocity = velocity.normalized * vLim;
    }
}


Vector3 boundingBox(GameObject boid) // Of the box, it will use force to push back boids.
{
    Vector3 v = Vector3.zero;


    if (boid.transform.position.x &lt; Xmin)
    {
        v.x =  Xmin - boid.transform.position.x;
    }
    else if (boid.transform.position.x &gt; Xmax)
    {
        v.x = Xmax - boid.transform.position.x;
    }
    if (boid.transform.position.y &lt; Ymin)
    {
        v.y = Ymin - boid.transform.position.y;
    }
    else if (boid.transform.position.y &gt; Ymax)
    {
        v.y = Ymax - boid.transform.position.y;
    }
    if (boid.transform.position.z &lt; Zmin)
    {
        v.z = Zmin - boid.transform.position.z;
    }
    else if (boid.transform.position.z &gt; Zmax)
    {
        v.z = Zmax - boid.transform.position.z;
    }
    return v;
}

public float Distance(Vector3 pos1, Vector3 pos2) // Distance Formula
{
    return Mathf.Sqrt((pos2.x - pos1.x) * (pos2.x - pos1.x)
    + (pos2.y - pos1.y) * (pos2.y - pos1.y) + (pos2.z - pos1.z) * (pos2.z - pos1.z));
}

public Vector3 rule1(GameObject Cohesion) // Rule1  = COHESION!
{
     // Center of mass
    if (target.isOn)
    {
        return (Target.transform.position - Cohesion.transform.position) / 100; // Moving 1% of boids to Target
    }

    else
        foreach (GameObject currentboid in boids)
        {
            if (currentboid != Cohesion)
                center = center + currentboid.transform.position;
        }
    center = center / (boids.Count - 1); // Center of Mass
    return (center - Cohesion.transform.position) / 100; // Cohesion, Moving 1%
}
</code></pre>

<p>public Vector3 rule2(GameObject separtion)
    {
        Vector3 center = new Vector3(0,0,0);
        foreach (GameObject currentboid in boids)
        {
            if(currentboid != separtion)
            {
                if (Distance(currentboid.transform.position, separtion.transform.position) &lt; 7) // Set Distance away from each other
                {
                    center = center - (currentboid.transform.position - separtion.transform.position);
                }
            }
        }
        return center;
    }</p>

<pre><code>public Vector3 rule3(GameObject Aligment)
{

    foreach (GameObject currentboid in boids)
    {
        if (currentboid != Aligment)
            pv += currentboid.GetComponent&lt;Boid&gt;().Vel;
    }
    pv = pv / (boids.Count - 1); // Center of Mass
    return (pv - Aligment.GetComponent&lt;Boid&gt;().Vel) / 1; // if / by 8 is 1/8, if 100, it's 1/100. 1 is GREAT!
}
</code></pre>

<p>}</p>

<h1>
<a id="file-boidcs" class="anchor" href="#file-boidcs" aria-hidden="true"><span class="octicon octicon-link"></span></a>File: Boid.cs</h1>

<p>class Boid:
using UnityEngine;
using System.Collections;
using System.Collections.Generic;</p>

<p>public class Boid : MonoBehaviour
{</p>

<pre><code>public Vector3 Vel;

float Mag(Vector3 pos1) // Magitude
{
    return Mathf.Sqrt((pos1.x) * (pos1.x) + (pos1.y) * (pos1.y) + (pos1.z) * (pos1.z)); // Direction = Vector / mag // Size == mag = vector3 / direction
}

void Update()
{
    transform.right = Vel.normalized;

    if (Input.GetKey("escape"))
    {
        Application.Quit();
    }
}
</code></pre>

<p>}</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/PaulChu756/Boid">Boid</a> is maintained by <a href="https://github.com/PaulChu756">PaulChu756</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
