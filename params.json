{"name":"Boid","tagline":"","body":"Paul Chu\r\nAIE Year 2 Programming\r\n\r\nI.0: Requirements Documentation\r\nI.1: Description of the Problem\r\nName: Boids \r\nProblem Statement: Boids is an Artificial intelligence behavior for flocking/herding behavior. \r\nProblem Specification:  These behaviors show similar behavior in flocks of birds or herds of cows/zebras. This simulation has three main behaviors that show to replicate life like forms. \r\n\r\nI.2: Input Information\r\nName: Boids\r\nDescription: Input of cohesion, separation, and alignment sliders.\r\nType: Unity/Visual Studio\r\nRange of Acceptable Values: Values were determined by the math. I multiply it with a small number with all the rules, so the program doesnâ€™t freak/glitch out. \r\n\r\nI.3: Output Information\r\nThe program will output a flocking/herding behavior similar to birds or herds of cows.\r\n\r\nI.4: User Interface Information\r\nA GUI will display for user after they input information. After, the user can increase/decrease values on via sliders displayed.\r\n\r\nII.0: Design Documentation\r\nII.1: System Architecture Description\r\nThe program is split into two different scripts for organization. The main script in this project is BoidController.cs, this is the main part of the project, it handles all the rules of this project.\r\n\r\n\r\nII.2: Information about the functions\r\nFile: BoidController.cs\r\n\r\nClass:SpawnBoidControllerner\r\nData Members: MonoBehaviour\r\n\r\nName: boids\r\nDescription: A list of GameObject\r\n\r\nName: cohesionslider\r\nDescription: A slider\r\n\r\nName: separtionslider\r\nDescription: A slider\r\n\r\nName: alignmentslider\r\nDescription: A slider\r\n\r\nName: Target\r\nDescription: A Gameobject\r\n\r\nName: target\r\nDescription: A Toggle\r\n\r\nName: boid\r\nDescription: A public Gameobject\r\n\r\nName: Xmin, Ymin, Zmin, Xmax, Ymax, Zmax \r\nDescription: Public integer that all equal zero. \r\n\r\nName: v1, v2, v3, v4, center, pv\r\nDescription: v1 to v1 are all velocities, center is the center velocity, pv is the perceived velocity.\r\n\r\n\r\nFunction: Start\r\nDescription: Spawns all the boids as the user begins the program.\r\n\r\nFunction: Update\r\nDescription: Applies all the rules to each boid each frame, and checks if the escape key is pressed to exit out the program.\r\n\r\nFunction: l_Vel\r\nParameters: GameObject lv\r\nDescription: This is the Limited Velocity, if the boid passes this limit, it will change the velocity so the boids do not break the program.\r\n\r\nFunction: Bounding Box\r\nParameters: Gameobject boid\r\nDescription: Creates a bounding box for the boids, it will push them back if they hit the bounding area.\r\n\r\nFunction: Distance\r\nParameters: Vector3 pos and pos2\r\nDescription: Distance formula between two boids\r\n\r\nFunction: rule1\r\nParameters: Gameobject Cohesion\r\nDescription: Finds the center of mass between all boids that are nearby, and the boids will fly closely to the center of mass.\r\n\r\nFunction: rule2\r\nParameters: Gameobject Separation\r\nDescription: Sets a distance away from each boid using distance formula\r\n\r\nFunction: rule3\r\nParameters: Gameobject Alignment\r\nDescription: Boids will fly in the same general direction of each other, instead of flying as individuals.\r\nFile: Boid.cs\r\nClass: Boid\r\nData Members: MonoBehaviour\r\n\r\nName: Vel\r\nDescription: Vector3 for velocity\r\n\r\nFunction: Mag\r\nParameters: Vector3 pos1\r\nDescription: Getting the magnitude by from position and direction / vector3\r\n\r\nFunction: Update\r\nDescription: Gets all the boid gameobjects to face correctly right, and checks if the escape key is pressed to exit program.\r\n\r\n\r\nIII.0: Implementation Documentation\r\nIII.1 Program Code\r\n#File: BoidController.cs\r\nusing UnityEngine;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine.UI;\r\n\r\npublic class BoidController : MonoBehaviour\r\n{\r\n    public List<GameObject> boids = new List<GameObject>();\r\n    public Slider cohesionslider;\r\n    public Slider separtionslider;\r\n    public Slider alignmentslider;\r\n    public GameObject Target;\r\n    public Toggle target;\r\n    public GameObject boid;\r\n    public float cFac, sFac, aFac, vLim;\r\n    public int Xmin = 0, Ymin = 0, Zmin = 0, Xmax = 0, Ymax = 0, Zmax = 0; // Draws Box\r\n\r\n    Vector3 v1;\r\n    Vector3 v2;\r\n    Vector3 v3;\r\n    Vector3 v4;\r\n    Vector3 center;\r\n    Vector3 pv;\r\n\r\n    /// <summary>\r\n    /// create the list of boids in random positions\r\n    /// </summary>\r\n    [ContextMenu(\"populate\")] // Matthew's code\r\n    void Populate()\r\n    {\r\n        GameObject bird;\r\n        for (int i = 0; i < 25; i++) // Control how many number of boids on Screen\r\n        {\r\n            bird = Instantiate(boid) as GameObject;\r\n            float rX = Random.Range(0, 20);\r\n            float rY = Random.Range(0, 20);\r\n            float rZ = Random.Range(0, 20);\r\n            bird.transform.position = new Vector3(rX, rY, rZ);\r\n            boids.Add(bird);\r\n        }\r\n    }\r\n\r\n    [ContextMenu(\"Unpopulate\")] // Matthew's code\r\n    void UnPopulate()\r\n    {\r\n        foreach(GameObject go in boids)\r\n        {\r\n            DestroyImmediate(go);\r\n        }\r\n        boids.Clear();\r\n    }\r\n\r\n    void Start()\r\n    {\r\n           GameObject bird;\r\n           for (int i = 0; i < 25; i++) // Control how many number of boids on Screen\r\n           {\r\n               bird = Instantiate(boid) as GameObject;\r\n               float rX = Random.Range(0, 20);\r\n               float rY = Random.Range(0, 20);\r\n               float rZ = Random.Range(0, 20);\r\n               bird.transform.position = new Vector3(rX, rY, rZ);\r\n               boids.Add(bird);\r\n           }\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        foreach (GameObject boid in boids)\r\n        {\r\n            v1 = rule1(boid) * cohesionslider.value * cFac; // Cohesion\r\n            v2 = rule2(boid) * separtionslider.value * sFac;\r\n            v3 = rule3(boid) * alignmentslider.value * aFac;\r\n            v4 = boundingBox(boid);\r\n            boid.GetComponent<Boid>().Vel = boid.GetComponent<Boid>().Vel + v1 + v2 + v3 + v4; // Vel + all rules\r\n            l_Vel(boid);\r\n            boid.transform.position = boid.transform.position + boid.GetComponent<Boid>().Vel; // Adding the pos + Vel\r\n        }\r\n        if (Input.GetKey(\"escape\"))\r\n        {\r\n            Application.Quit();\r\n        }\r\n    }\r\n\r\n    void l_Vel(GameObject lv) // Velocity Limit\r\n    {\r\n        Vector3 velocity = lv.GetComponent<Boid>().Vel;\r\n        if (velocity.magnitude > vLim)\r\n        {\r\n            velocity = velocity.normalized * vLim;\r\n        }\r\n    }\r\n\r\n\r\n    Vector3 boundingBox(GameObject boid) // Of the box, it will use force to push back boids.\r\n    {\r\n        Vector3 v = Vector3.zero;\r\n        \r\n\r\n        if (boid.transform.position.x < Xmin)\r\n        {\r\n            v.x =  Xmin - boid.transform.position.x;\r\n        }\r\n        else if (boid.transform.position.x > Xmax)\r\n        {\r\n            v.x = Xmax - boid.transform.position.x;\r\n        }\r\n        if (boid.transform.position.y < Ymin)\r\n        {\r\n            v.y = Ymin - boid.transform.position.y;\r\n        }\r\n        else if (boid.transform.position.y > Ymax)\r\n        {\r\n            v.y = Ymax - boid.transform.position.y;\r\n        }\r\n        if (boid.transform.position.z < Zmin)\r\n        {\r\n            v.z = Zmin - boid.transform.position.z;\r\n        }\r\n        else if (boid.transform.position.z > Zmax)\r\n        {\r\n            v.z = Zmax - boid.transform.position.z;\r\n        }\r\n        return v;\r\n    }\r\n\r\n    public float Distance(Vector3 pos1, Vector3 pos2) // Distance Formula\r\n    {\r\n        return Mathf.Sqrt((pos2.x - pos1.x) * (pos2.x - pos1.x)\r\n        + (pos2.y - pos1.y) * (pos2.y - pos1.y) + (pos2.z - pos1.z) * (pos2.z - pos1.z));\r\n    }\r\n\r\n    public Vector3 rule1(GameObject Cohesion) // Rule1  = COHESION!\r\n    {\r\n         // Center of mass\r\n        if (target.isOn)\r\n        {\r\n            return (Target.transform.position - Cohesion.transform.position) / 100; // Moving 1% of boids to Target\r\n        }\r\n\r\n        else\r\n            foreach (GameObject currentboid in boids)\r\n            {\r\n                if (currentboid != Cohesion)\r\n                    center = center + currentboid.transform.position;\r\n            }\r\n        center = center / (boids.Count - 1); // Center of Mass\r\n        return (center - Cohesion.transform.position) / 100; // Cohesion, Moving 1%\r\n    }\r\n\r\n   public Vector3 rule2(GameObject separtion)\r\n    {\r\n        Vector3 center = new Vector3(0,0,0);\r\n        foreach (GameObject currentboid in boids)\r\n        {\r\n            if(currentboid != separtion)\r\n            {\r\n                if (Distance(currentboid.transform.position, separtion.transform.position) < 7) // Set Distance away from each other\r\n                {\r\n                    center = center - (currentboid.transform.position - separtion.transform.position);\r\n                }\r\n            }\r\n        }\r\n        return center;\r\n    }\r\n\r\n    public Vector3 rule3(GameObject Aligment)\r\n    {\r\n        \r\n        foreach (GameObject currentboid in boids)\r\n        {\r\n            if (currentboid != Aligment)\r\n                pv += currentboid.GetComponent<Boid>().Vel;\r\n        }\r\n        pv = pv / (boids.Count - 1); // Center of Mass\r\n        return (pv - Aligment.GetComponent<Boid>().Vel) / 1; // if / by 8 is 1/8, if 100, it's 1/100. 1 is GREAT!\r\n    }\r\n}\r\n\r\n#File: Boid.cs\r\nclass Boid:\r\nusing UnityEngine;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\n\r\npublic class Boid : MonoBehaviour\r\n{\r\n\r\n    public Vector3 Vel;\r\n\r\n    float Mag(Vector3 pos1) // Magitude\r\n    {\r\n        return Mathf.Sqrt((pos1.x) * (pos1.x) + (pos1.y) * (pos1.y) + (pos1.z) * (pos1.z)); // Direction = Vector / mag // Size == mag = vector3 / direction\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        transform.right = Vel.normalized;\r\n\r\n        if (Input.GetKey(\"escape\"))\r\n        {\r\n            Application.Quit();\r\n        }\r\n    }\r\n}\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}